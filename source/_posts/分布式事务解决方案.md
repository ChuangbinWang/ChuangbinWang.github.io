---
title: 分布式事务解决方案
date: 2019-09-20 12:42:07
categories: 
    -后端知识
tags:
    -服务器
    -分布式事务
---
当我们的单个数据库的性能产生瓶颈的时候，我们可能会对数据库进行分区，这里所说的分区指的是物理分区，分区之后可能不同的库就处于不同的服务器上了，这个时候单个数据库的ACID已经不能适应这种情况。于是使用新的理论来保证分布式事务的一致性。

CAP定理
一致性(Consistency) ：保证服务中所有的节点保存的数据都是一致的。

可用性(Availability) ： 读写操作在单台服务器出问题后，在其他服务器上依然能够完成读写操作
重点在于：某个读写操作在出问题的机器上不能读写了，但是在其他机器可以完成 

分区容错性(Partition tolerance) ： 即使出现单个组件无法可用,操作依然可以完成。（分布式系统遇到网络分区故障的时候，某个分区故障了，但是其他的分区还可用保证一致性和可用性。这样丧失了分区容错性。且剩下的服务不会因为坏掉的部分节点而丧失一致性和可用性）
重点在于：部分服务器因网络问题，业务依然能够继续运行

三种特性只能同时满足两个。可以使用zookeeper和euraka架构的例子。zookeeper使用leader选举（这个制度，会导致这个服务组件无法对外提供服务丧失了可用性）制度保证了一致性和分区容错性，服务实例自动切换euraka节点（由于原euraka节点挂掉了，但euraka上面的数据还没同步到其他节点上，此时即使服务实例切换了节点，但是在一致性上就没有得到保障，虽然服务实例通过心跳包机制或者ack机制，发现实例挂掉了，再重新注册，保障了最终一致性。）重新注册保证了可用性和分区容错性。

![pic_1](/images/clipboard.png)
在分布式系统中，我们往往追求的是可用性，它的重要程序比一致性要高，那么如何实现高可用性呢？ 前人已经给我们提出来了另外一个理论，就是BASE理论

Basically Available（基本可用）
Soft state（软状态）
Eventually consistent（最终一致性）

BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性



常见的处理方式有：
基于XA协议的两阶段提交方案，TCC方案，基于消息的最终一致性方案

基于XA协议的两阶段提交方案：
事务调度器和分布在各地的资源管理器通过两阶段提交方式来完成一个全局事务。第一阶段是表决阶段，所有参与者都将本事务能否成功的信息反馈发给协调者；第二阶段是执行阶段，协调者根据所有参与者的反馈，通知所有参与者，步调一致地在所有分支上提交或者回滚。
虽然两阶段提交方案应用非常广泛，几乎所有商业OLTP数据库都支持XA协议。
存在的问题有：
2.1 同步阻塞 所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。
2.2 单点问题 协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。
2.3 数据不一致 在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。
2.4 太过保守 任意一个节点失败就会导致整个事务失败，没有完善的容错机制。
![pic_1](/images/clipboard2.png)

TCC方案：
TCC方案在电商、金融领域落地较多。这种方案不借助MQ。它类似于关系型数据库事务的三种操作：DML、Commit和Rollback，其将整个业务逻辑的每个分支显式的分成了Try、Confirm、Cancel三个操作。Try部分完成业务的准备工作，confirm部分完成业务的提交，cancel部分完成事务的回滚。
事务开始时，业务应用会向事务协调器注册启动事务。之后业务应用会调用所有服务的try接口，完成一阶段准备。之后业务应用收到try接口的返回情况，然后决定给事务调度器调用confirm接口或者cancel接口。如果接口调用失败，会进行重试。

![pic_1](/images/clipboard3.png)
![pic_1](/images/clipboard4.png)

TCC方案让应用自己定义数据库操作的粒度（粒度小主要体现在，相较于2pc方式，try阶段相较于2pc的预备阶段，它提前锁定资源的，然后再执行后续操作，如果confirm执行超时或者失败即可回退，而2pc的预备阶段是先把需要的资源锁住，如果资源不够就返回失败，在执行提交事务的过程中如果某一个操作执行失败，那么由于没有回退操作，那么其他资源就会一直被锁定）。
由于Confirm和Cancel操作可能被重复调用，故要求Confirm和Cancel两个接口必须是幂等的。
缺点：
  ● 对应用的侵入性强。业务逻辑的每个分支都需要实现try、confirm、cancel三个操作，应用侵入性较强，改造成本高。
  ● 实现难度较大。需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。为了满足一致性的要求，confirm和cancel接口必须实现幂等。

基于本地消息表的最终一致性方案：
核心思想是将分布式事务拆分成本地事务进行处理。
消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。
如果消息发送到消息队列或者消息消费放失败，会进行重试发送。
消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，就会发一个消息返回给消息生产方，修改消息表中的状态。如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。
![pic_1](/images/clipboard5.png)
这种方案遵循BASE理论，采用的是最终一致性，笔者认为是这几种方案里面比较适合实际业务场景的，即不会出现像2PC那样复杂的实现(当调用链很长的时候，2PC的可用性是非常低的)，也不会像TCC那样可能出现确认或者回滚不了的情况。
优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。
缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。

基于消息队列的事务方式方案：
有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交，但是市面上一些主流的MQ都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。
操作流程如下：
1.发送prepare消息，该消息对Consumer不可见
2.执行本地事务
3.若本地事务执行成功，则向MQ提交消息确认发送指令；若本地事务执行失败，则向MQ发送取消指令
4.若MQ长时间未收到确认发送或取消发送的指令，则向业务系统询问本地事务状态，并做补偿处理。
![pic_1](/images/clipboard6.png)
优点： 实现了最终一致性，不需要依赖本地数据库事务。也不依赖分布式事务。
缺点： 实现难度大，主流MQ不支持。
